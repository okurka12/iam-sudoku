##################
##  Vit Pavlik  ##
##   xpavli0a   ##
##    251301    ##
##     2024     ##
##################

#
# sudoku to propositional logic
#
#
# used python version: Python 3.12.3 (GCC 13.1.0) on Debian 12.5
#
import sys
from typing import List, Tuple, Iterable
from itertools import combinations

STATUS_ERR = 5

MINISAT_VERSION = "Debian package minisat 1:2.2.1-5+b3 (bookworm)"

# do you want to report progress?
VERBOSE = True


class Position:
    """class representing a number on the sudoku plane that is given"""

    def __init__(self, x: int, y: int, value: int) -> None:

        assert_position_values(x, y, value)
        self.x = x
        self.y = y
        self.value = value


class Clause:
    """class representing a list of literals"""

    def __init__(self, *args: int) -> None:
        assert all([isinstance(arg, int)] for arg in args)
        self.literals: List[int] = []
        self.literals.extend(args)

    def get_literals(self) -> List[int]:
        return self.literals

class Formula:
    """a class representing the CNF formula"""

    def __init__(self) -> None:
        self.clauses: List[Clause] = []
        report_progress("generating rules: only one value")
        self.only_one_value()
        report_progress("generating rules: rows, columns and segments")
        self.rows_columns_segments()
        report_progress("generating rules: at least one number on position")
        self.generate_numbers()

    def add_clause(self, *args: int) -> None:
        self.clauses.append(Clause(*args))

    def only_one_value(self) -> None:
        """
        adds clauses that say: only one value can be true at one place
        """
        for x in range(9):
            for y in range(9):

                # for every pair of values at one position, one of them is
                # false
                for value1, value2 in combinations(range(1, 10), 2):
                    idx1 = get_index(x, y, value1)
                    idx2 = get_index(x, y, value2)
                    self.add_clause(-idx1, -idx2)

    def one_row_one_column(self, rci: int) -> None:
        """to be used in rows_columns_segments"""

        # for every pair of ones, twos, threes... on the same row/column (rci),
        # one of them is false
        for value in range(1, 10):
            for idx1, idx2 in combinations(range(9), 2):

                # row
                r1 = get_index(idx1, rci, value)
                r2 = get_index(idx2, rci, value)
                self.add_clause(-r1, -r2)

                # column
                c1 = get_index(rci, idx1, value)
                c2 = get_index(rci, idx2, value)
                self.add_clause(-c1, -c2)

    def rows_columns_segments(self) -> None:
        """
        general sudoku rule: only one of each number on each row/column
        """
        for n in range(9):
            self.one_row_one_column(n)
            self.one_segment(n)

    def one_segment(self, n: int) -> None:
        """
        generate clauses for numbers in nth segment (n is 0 to 8)
        """
        for value in range(1, 10):
            for p, q in combinations(segment_coordinates(n), 2):
                px, py = p
                idx1 = get_index(px, py, value)
                qx, qy = q
                idx2 = get_index(qx, qy, value)
                self.add_clause(-idx1, -idx2)



    def generate_numbers(self) -> None:
        """
        ad clauses that there is at least one number on each position
        """
        for x in range(9):
            for y in range(9):
                indices = [get_index(x, y, value) for value in range(1, 10)]
                self.add_clause(*indices)

    def add_positions(self, positions: List[Position]) -> None:
        """
        add clauses for each of the inputted positions
        """
        for pos in positions:
            self.add_clause(get_index(pos.x, pos.y, pos.value))

    def print(self) -> None:
        """
        print the formula in DIMACS on stdout
        """
        print(f"c ")
        print(f"c DIMACS CNF formula for sudoku")
        print(f"c generated by sudoku.py, Vit Pavlik (xpavli0a)")
        print(f"c ")
        print(f"c should work with the following minisat version:")
        print(f"c {MINISAT_VERSION}")
        print(f"c ")
        print(f"p cnf {9 * 9 * 9} {len(self.clauses)}")
        for clause in self.clauses:
            print(" ".join([str(lt) for lt in clause.get_literals()]),
                  end=" 0\n")


def report_progress(*args, **kwargs) -> None:
    """
    report progress on stderr and flush stderr, use like print
    """
    assert "file" not in kwargs
    assert "flush" not in kwargs
    print(*args, **kwargs, flush=True, file=sys.stderr)


def assert_position_values(x: int, y: int, value: int) -> None:
    """
    asserts that x, y coordinates (0 to 8) and value (1 to 9) are all int and
    in range
    """
    assert isinstance(x, int)
    assert isinstance(y, int)
    assert isinstance(value, int)
    assert 0 <= x <= 8
    assert 0 <= y <= 8
    assert 1 <= value <= 9


def segment_coordinates(n: int) -> Iterable[Tuple[int, int]]:
    """
    yields x-y coordinates of the positions in the n-th segment (n is 0 to 8)
    the segmends are numbered like this:
    ```txt
    #############
    # 0 | 1 | 2 #
    #-----------#
    # 3 | 4 | 5 #
    #-----------#
    # 6 | 7 | 8 #
    #############
    ```
    """
    assert 0 <= n <= 8
    x_offset = 3 * (n % 3)
    y_offset = 3 * (n // 3)
    for x in range(x_offset, x_offset + 3):
        for y in range(y_offset, y_offset + 3):
            yield x, y


def get_index(x: int, y: int, value: int) -> int:
    """
    returns an index of the variable at position x, y (0 to 8)
    with value (1 to 9)

    example values:
    ```txt
    x=0, y=0, value=1 -> 1
    x=0, y=0, value=2 -> 2
    x=0, y=0, value=3 -> 3
    x=1, y=0, value=1 -> 10
    x=1, y=0, value=2 -> 11
    x=2, y=0, value=1 -> 19
    x=2, y=0, value=2 -> 20
    x=0, y=1, value=1 -> 82
    x=0, y=1, value=2 -> 83
    ```
    """
    assert_position_values(x, y, value)
    return 9 * 9 * y + 9 * x + value


def process_line(line: str, line_number: int) -> Position:
    """process a single line, EXIT on error"""
    try:
        splitted = line.split()
        x = int(splitted[1]) - 1
        y = int(splitted[0]) - 1
        value = int(splitted[2])
        output = Position(x, y, value)
    except Exception as e:
        print(e, file=sys.stderr)
        print(f"something went wrong when processing line {line_number}:",
              file=sys.stderr)
        print(line, file=sys.stderr)
        print("abort", file=sys.stderr)
        exit(STATUS_ERR)
    return output


def read_input() -> List[Position]:
    output = []

    line_number = 1
    eof_reached = False
    while not eof_reached:
        try:
            line = input()

            # skip empty lines
            if line.isspace() or len(line) == 0:
                continue

            output.append(process_line(line, line_number))
            line_number += 1
        except EOFError:
            eof_reached = True

    return output


def main() -> None:
    formula = Formula()
    formula.add_positions(read_input())
    formula.print()


if __name__ == "__main__":
    main()
